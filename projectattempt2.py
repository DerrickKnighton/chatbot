# -*- coding: utf-8 -*-
"""projectattempt2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ElQNtWMDy_Cp3cnwQMDXHcjqZWZbGsvr
"""

# Load NLTK
import nltk
from nltk import grammar, parse
import spacy

#Load spacy lemmatizer
nlp = spacy.load("en_core_web_sm")

#input sentence do not forget puncuation
#some examples i can currently handle

#Declarative sentences
# A tall skinny man sneezed.
#Sam bought Mia a black sedan.
#Robin was interrupted by a drunk sailor. 
#Sam is a tall man.
#a mouse scared Robin.
#Robin likes Sam
#every sailor is a man.
#Olive likes the blue sky.
#Derrick drove the car around the corner.
#a fat tall man left the dealership.
#Derrick drove the black car around the corner.
#every woman is a funny person.
#a woman ordered robin a black sedan.

#yes no questions
#is Sam a tall man? (yes)
#did Sam buy a black sedan in the dealership? (yes)
#Was Robin interrupted by a drunk sailor? (yes)
#Was a drunk sailor interrupted by Robin? (no)
#did mia buy daniel a fish? (yes)
#did a mouse scare Robin? (yes)
#does Sam like Robin? (no)
#did Mia give Olive a hotdog? (yes)
#does Olive like the blue sky? (yes)
#did Derrick drive the black car around the corner? (yes)
#did a fat tall man leave the dealership? (yes)
#does a funny girl like those pickles? (yes)
#did a woman order robin a black sedan? (yes)
#did derrick pass the cse467 project? (yes) .... hopefully =)

#Wh-Questions
#what did Olive chase? (sam)
#who did Sam see? (Olive)
#what did a drunk sailor see? (Olive)

#remember correct punctuation or it won't work
input = nlp("did bender read a paper?")

uninflectedTokens = []

inputAsString = ""

#store all lemmatized tokens in uninflectedTokens
for token in input:
  uninflectedTokens.append(token.lemma_)
  inputAsString = inputAsString + " " + token.lemma_
#print(uninflectedTokens)
print(inputAsString)

#mode 1 = Declarative sentences
#mode 2 = yes no questions
#mode 3 = Wh-Questions
mode = 0

if "." in inputAsString:
  mode = 1
  print("Declarative sentences Mode")
elif "who" in inputAsString or "what" in inputAsString:
  mode = 3
  print("Wh-Questions Mode")
elif "be" in inputAsString or "do" in inputAsString:
  mode = 2
  print("yes no questions Mode")

# Commented out IPython magic to ensure Python compatibility.
# Define grammar
gs = r"""
# % start S
############################
# Grammar Rules
#############################

S[SEM = <?subj(?vp)>] -> NP[SEM=?subj] VP[SEM=?vp] declarePunc
S[SEM = <?subj(?vp)>] -> NP[SEM=?subj] AUX VP[SEM=?vp] declarePunc
S[SEM = <?subj(?vp)>] -> AUX NP[SEM=?subj] VP[SEM=?vp] questionPunc
S[SEM = <?s>] -> WHP S[SEM=?s]/NP questionPunc

# wh-questions with gaps
S[QC=wh,SEM = <?subj(?vp)>]/NP -> AUX NP[SEM=?subj] VP[SEM=?vp]/NP 
TV[SEM=<?v(\P.P(w))>]/NP -> TV[SEM=?v]

#for y/n questions
S[SEM = <?subj(?vp)>]/NP -> AUX NP[SEM=?subj] VP[SEM=?vp]/NP questionPunc


NP[SEM=<?det(?nom)>] -> DT[SEM=?det]  N[SEM=?nom] 
NP[SEM=?np] -> PN[SEM=?np] 

VP[SEM=?v] -> IV[SEM=?v]

#active vs passive rules
VP[SEM=<?v(?obj)>] -> TV[VC= active,SEM=?v] NP[SEM=?obj]
VP[VC=pass,SEM=<?v(?obj)>] -> TV[VC=pass,SEM=?v] PP[PFORM=passive_by,SEM=?obj]
VP[SEM=<?v>]/NP -> TV[SEM=?v]/NP


VP[SEM=<?v(?obj,?pp)>] -> DTV[SEM=?v] NP[SEM=?obj] PP[SEM=?pp]
VP[SEM=<?v(?obj,?np)>] -> DTV[SEM=?v] NP[SEM=?obj] NP[SEM=?np]

#PN is a N 
VP[SEM=<?nom>] -> DT[SEM=?det]  N[SEM=?nom] 

PP[SEM=<?p(?np)>] -> P[SEM=?p] NP[SEM=?np]
PP[PFORM=?p,SEM=?np] -> P[PFORM=?p]  NP[SEM=?np]

N[SEM=<?pp(?n)>] -> N[SEM=?n] PP[SEM=?pp]

N[SEM=<?adj(?n)>] -> ADJ[SEM=?adj] N[SEM=?n]

#############################
# Lexical entries
#############################
#############################
# 15 proper names
#############################
PN[SEM=<\P.P(Sam)>] -> 'Sam'
PN[SEM=<\P.P(Sam)>] -> 'sam'
PN[SEM=<\P.P(Robin)>] -> 'Robin'
PN[SEM=<\P.P(Robin)>] -> 'robin'
PN[SEM=<\P.P(Mia)>] -> 'Mia'
PN[SEM=<\P.P(Mia)>] -> 'mia'
PN[SEM=<\P.P(Olive)>] -> 'Olive'
PN[SEM=<\P.P(Olive)>] -> 'olive'
PN[SEM=<\P.P(Cyril)>] -> 'Cyril'
PN[SEM=<\P.P(Cyril)>] -> 'cyril'
PN[SEM=<\P.P(Derrick)>] -> 'Derrick'
PN[SEM=<\P.P(Derrick)>] -> 'derrick'
PN[SEM=<\P.P(Daniel)>] -> 'Daniel'
PN[SEM=<\P.P(Daniel)>] -> 'daniel'
PN[SEM=<\P.P(Roberto)>] -> 'Roberto'
PN[SEM=<\P.P(Roberto)>] -> 'roberto'
PN[SEM=<\P.P(Bender)>] -> 'Bender'
PN[SEM=<\P.P(Bender)>] -> 'bender'
PN[SEM=<\P.P(Horatio)>] -> 'Horatio'
PN[SEM=<\P.P(Horatio)>] -> 'horatio'
PN[SEM=<\P.P(Adam)>] -> 'Adam'
PN[SEM=<\P.P(Adam)>] -> 'adam'
PN[SEM=<\P.P(Steve)>] -> 'Steve'
PN[SEM=<\P.P(Steve)>] -> 'steve'
PN[SEM=<\P.P(Yosef)>] -> 'Yosef'
PN[SEM=<\P.P(Yosef)>] -> 'yosef'
PN[SEM=<\P.P(Donald)>] -> 'Donald'
PN[SEM=<\P.P(Donald)>] -> 'donald'
PN[SEM=<\P.P(Scott)>] -> 'Scott'
PN[SEM=<\P.P(Scott)>] -> 'scott'
PN[SEM=<\P.P(Geralt)>] -> 'Geralt'
PN[SEM=<\P.P(Geralt)>] -> 'geralt'
################################

################################
# 10 determiners
################################
DT[SEM=<\P Q.all x.(P(x) -> Q(x))>] -> 'every'
DT[SEM=<\P Q.all x.(P(x) -> Q(x))>] -> 'all'
DT[SEM=<\P Q.exists x.(P(x) & Q(x))>] -> 'some'
DT[SEM=<\P Q.exists x.(P(x) & Q(x))>] -> 'a'
DT[SEM=<\P Q.exists x.(P(x) & Q(x))>] -> 'an'
DT[SEM=<\P Q.exists x.(P(x) & Q(x))>] -> 'the'
DT[SEM=<\P Q.exists x.(P(x) & Q(x))>] -> 'that'
DT[SEM=<\P Q.exists x.(P(x) & Q(x))>] -> 'this'
DT[SEM=<\P Q.exists x.(P(x) & Q(x))>] -> 'those'
DT[SEM=<\P Q.exists x.(P(x) & Q(x))>] -> 'such'
################################

################################
#50 common nouns
################################
N[SEM=<\x.man(x)>] -> 'man'
N[SEM=<\x.girl(x)>] -> 'girl'
N[SEM=<\x.boy(x)>] -> 'boy'
N[SEM=<\x.dog(x)>] -> 'dog'
N[SEM=<\x.cat(x)>] -> 'cat'
N[SEM=<\x.sedan(x)>] -> 'sedan'
N[SEM=<\x.dealership(x)>] -> 'dealership'
N[SEM=<\x.corner(x)>] -> 'corner'
N[SEM=<\x.brochure(x)>] -> 'brochure'
N[SEM=<\x.customer(x)>] -> 'customer'
N[SEM=<\x.moustache(x)>] -> 'moustache'
N[SEM=<\x.mouse(x)>] -> 'mouse'
N[SEM=<\x.hotdog(x)>] -> 'hotdog'
N[SEM=<\x.house(x)>] -> 'house'
N[SEM=<\x.tree(x)>] -> 'tree'
N[SEM=<\x.sky(x)>] -> 'sky'
N[SEM=<\x.food(x)>] -> 'food'
N[SEM=<\x.truck(x)>] -> 'truck'
N[SEM=<\x.alien(x)>] -> 'alien'
N[SEM=<\x.captain(x)>] -> 'captain'
N[SEM=<\x.sailor(x)>] -> 'sailor'
N[SEM=<\x.corner(x)>] -> 'corner'
N[SEM=<\x.car(x)>] -> 'car'
N[SEM=<\x.burger(x)>] -> 'burger'
N[SEM=<\x.mansion(x)>] -> 'mansion'
N[SEM=<\x.submarine(x)>] -> 'submarine'
N[SEM=<\x.knight(x)>] -> 'knight'
N[SEM=<\x.fish(x)>] -> 'fish'
N[SEM=<\x.plane(x)>] -> 'plane'
N[SEM=<\x.pickle(x)>] -> 'pickle'
N[SEM=<\x.moon(x)>] -> 'moon'
N[SEM=<\x.ball(x)>] -> 'ball'
N[SEM=<\x.chalk(x)>] -> 'chalk'
N[SEM=<\x.woman(x)>] -> 'woman'
N[SEM=<\x.people(x)>] -> 'people'
N[SEM=<\x.people(x)>] -> 'person'
N[SEM=<\x.firetruck(x)>] -> 'firetruck'
N[SEM=<\x.dumptruck(x)>] -> 'dumptruck'
N[SEM=<\x.ufo(x)>] -> 'ufo'
N[SEM=<\x.airplane(x)>] -> 'airplane'
N[SEM=<\x.computer(x)>] -> 'computer'
N[SEM=<\x.project(x)>] -> 'project'
N[SEM=<\x.paper(x)>] -> 'paper'
N[SEM=<\x.sign(x)>] -> 'sign'
N[SEM=<\x.line(x)>] -> 'line'
N[SEM=<\x.iphone(x)>] -> 'iphone'
#############################

#############################
# 10 prepositions
#############################
P[SEM=<\P Q x.((Q(x) & P(\y.in(x,y)) ))>] -> 'in'
P[SEM=<\P Q x.((Q(x) & P(\y.near(x,y)) ))>] -> 'near'
P[SEM=<\P Q x.((Q(x) & P(\y.around(x,y)) ))>] -> 'around'
P[SEM=<\P Q x.((Q(x) & P(\y.to(x,y)) ))>] -> 'to'
P[SEM=<\P Q x.((Q(x) & P(\y.with(x,y)) ))>] -> 'with'
P[PFORM=passive_by] -> 'by'
#############################

#############################
# 15 adjectives
#############################
ADJ[SEM=<\P x.((P(x) & blue(x)))>] -> 'blue'
ADJ[SEM=<\P x.((P(x) & black(x)))>] -> 'black'
ADJ[SEM=<\P x.((P(x) & tall(x)))>] -> 'tall'
ADJ[SEM=<\P x.((P(x) & skinny(x)))>] -> 'skinny'
ADJ[SEM=<\P x.((P(x) & fat(x)))>] -> 'fat'
ADJ[SEM=<\P x.((P(x) & white(x)))>] -> 'white'
ADJ[SEM=<\P x.((P(x) & short(x)))>] -> 'short'
ADJ[SEM=<\P x.((P(x) & funny(x)))>] -> 'funny'
ADJ[SEM=<\P x.((P(x) & awesome(x)))>] -> 'awesome'
ADJ[SEM=<\P x.((P(x) & hairy(x)))>] -> 'hairy'
ADJ[SEM=<\P x.((P(x) & smart(x)))>] -> 'smart'
ADJ[SEM=<\P x.((P(x) & dumb(x)))>] -> 'dumb'
ADJ[SEM=<\P x.((P(x) & savy(x)))>] -> 'savy'
ADJ[SEM=<\P x.((P(x) & annoying(x)))>] -> 'annoying'
ADJ[SEM=<\P x.((P(x) & drunk(x)))>] -> 'drunk'
ADJ[SEM=<\P x.((P(x) & cse467(x)))>] -> 'cse467'
##############################

##############################
# 30 verbs
##############################

IV[SEM=<\x.sneeze(x)>] -> 'sneeze'
IV[SEM=<\x.walk(x)>] -> 'walk'
IV[SEM=<\x.interrupt(x)>] -> 'interrupt'
IV[SEM=<\x.smile(x)>] -> 'smile'
IV[SEM=<\x.cry(x)>] -> 'cry'
IV[SEM=<\x.die(x)>] -> 'die'
IV[SEM=<\x.lie(x)>] -> 'lie'
IV[SEM=<\x.speak(x)>] -> 'speak'
IV[SEM=<\x.fly(x)>] -> 'fly'

TV[VC=active,SEM=<\P x.P(\y.chase(x,y))>] -> 'chase'
TV[VC=pass,SEM=<\P x.P(\y.chase(y,x))>] -> 'chase'
TV[QC=wh,SEM=<\P x.P(\y.chase(x,y))>] -> 'chase'

TV[VC=active,SEM=<\P x.P(\y.see(x,y))>] -> 'see'
TV[VC=pass,SEM=<\P x.P(\y.see(y,x))>] -> 'see'
TV[QC=wh,SEM=<\P x.P(\y.see(x,y))>] -> 'see'

TV[VC=active,SEM=<\P x.P(\y.pass(x,y))>] -> 'pass'
TV[VC=pass,SEM=<\P x.P(\y.pass(y,x))>] -> 'pass'
TV[QC=wh,SEM=<\P x.P(\y.pass(x,y))>] -> 'pass'

TV[VC=active,SEM=<\P x.P(\y.scare(x,y))>] -> 'scare'
TV[VC=pass,SEM=<\P x.P(\y.scare(y,x))>] -> 'scare'
TV[QC=wh,SEM=<\P x.P(\y.scare(x,y))>] -> 'scare'

TV[VC=active,SEM=<\P x.P(\y.like(x,y))>] -> 'like'
TV[VC=pass,SEM=<\P x.P(\y.like(y,x))>] -> 'like'
TV[QC=wh,SEM=<\P x.P(\y.like(x,y))>] -> 'like'

TV[VC=active,SEM=<\P x.P(\y.pay(x,y))>] -> 'pay'
TV[VC=pass,SEM=<\P x.P(\y.pay(y,x))>] -> 'pay'
TV[QC=wh,SEM=<\P x.P(\y.pay(x,y))>] -> 'pay'


TV[VC=active,SEM=<\P x.P(\y.show(x,y))>] -> 'show'
TV[VC=pass,SEM=<\P x.P(\y.show(y,x))>] -> 'show'
TV[QC=wh,SEM=<\P x.P(\y.show(x,y))>] -> 'show'

TV[VC=active,SEM=<\P x.P(\y.read(x,y))>] -> 'read'
TV[VC=pass,SEM=<\P x.P(\y.read(y,x))>] -> 'read'
TV[QC=wh,SEM=<\P x.P(\y.read(x,y))>] -> 'read'

TV[VC=active,SEM=<\P x.P(\y.interrupt(x,y))>] -> 'interrupt'
TV[VC=pass,SEM=<\P x.P(\y.interrupt(y,x))>] -> 'interrupt'
TV[QC=wh,SEM=<\P x.P(\y.interrupt(x,y))>] -> 'interrupt'

TV[VC=active,SEM=<\P x.P(\y.leave(x,y))>] -> 'leave'
TV[VC=pass,SEM=<\P x.P(\y.leave(y,x))>] -> 'leave'
TV[QC=wh,SEM=<\P x.P(\y.leave(x,y))>] -> 'leave'

DTV[SEM=<\P Q x.Q(\z.P(\y.give(x,y,z)))>] -> 'give'
DTV[SEM=<\P Q x.Q(\z.P(\y.send(x,y,z)))>] -> 'send'
DTV[SEM=<\P Q x.Q(\z.P(\y.order(x,y,z)))>] -> 'order'
DTV[SEM=<\P Q x.Q(\z.P(\y.buy(x,y,z)))>] -> 'buy'
DTV[SEM=<\P Q x.Q(\z.P(\y.drive(x,y,z)))>] -> 'drive'

################################

declarePunc -> '.'
questionPunc -> '?'
AUX -> 'do' | 'be'
WHP -> 'what' | 'who'
"""

# Load grammar
grammar2 = nltk.grammar.FeatureGrammar.fromstring(gs)

# Input
#sentence = 'every man sneezed'
sentence = inputAsString

#  Tokenize input into list of words
tokens = sentence.split()

# Select parser
#parser = parse.FeatureEarleyChartParser(grammar)
parser = nltk.parse.FeatureChartParser(grammar2)

# Find all semantic representations for all parses 
for tree in parser.parse(tokens):
    print(tree.label()['SEM'])

v = """

##################
# 15 proper names
##################
Sam => sam
Olive => olive
Cyril => cyril
Robin => robin
Mia => mia
Derrick => derrick
Daniel => daniel
Roberto => roberto
Bender => bender
Horatio => horatio
Adam => adam
Steve => steve
Yosef => yosef
Donald => donald
Scott => scott
Geralt => geralt
###################

##################
# 50 common nouns
##################
boy => {derrick,daniel,roberto,bender,horatio}
girl => {robin,olive}
man => {sam,adam,steve,yosef,donald,scott,geralt,roberto}
woman => {robin,olive,mia}
people => {derrick,daniel,roberto,bender,horatio,robin,olive,mia}
dog => {dog1}
sailor => {sam,derrick,daniel}
dealership => {dealership1}
sedan => {sedan1,sedan2}
hotdog => {hotdog1}
mouse => {mouse1}
house => {house1}
sky => {sky}
car => {car1,car2,sedan1,sedan2}
corner => {corner}
burger => {burger1}
mansion => {mansion1}
alien => {geralt,derrick}
tree => {tree1}
customer => {adam,steve,daniel}
firetruck => {firetruck1}
dumptruck => {dumptruck1}
truck => {truck1,firetruck1,dumptruck1}
captain => {olive,mia}
submarine => {submarine1}
knight => {derrick, mia}
fish => {fish1, fish2}
plane => {plane1}
pickle => {pickle1}
moon => {moon1}
ball => {ball1}
chalk => {chalk1}
ufo => {ufo1}
airplane => {airplane1}
computer => {computer1}
project => {project1}
paper => {paper1}
sign => {sign1}
line => {line1}
theater => {theater1}
iphone => {iphone1}

##################
# 15 adjectives
##################
tall => {sam,derrick,roberto}
skinny => {sam}
drunk => {sam}
black => {sedan1,car1}
blue => {sky,moon1,sign1,ufo1}
fat => {daniel,donald,yosef,roberto}
white => {derrick,geralt,bender,chalk1,line1}
short => {bender,adam,steve}
funny => {mia,robin,olive}
awesome => {derrick,sam}
hairy => {bender,yosef}
smart => {derrick,sam,cyril}
dumb => {adam,horatio}
savy => {daniel,mia,sam,robin}
annoying => {steve}
cse467 => {project1}
#################

#################
# 30 verbs
#################
smile => {derrick}
walk => {olive}
sneeze => {sam}
cry => {roberto,robin,yosef}
die => {geralt}
lie => {derrick,mia,adam}
speak => {derrick,horatio}
fly => {ufo1,airplane1}

show => {(derrick,sedan1),(mia,tree1)}
pay => {(roberto,yosef),(derrick,scott),(olive,mia),(geralt,theater1)}
scare => {(mouse1,robin)}
interrupt => {(sam,robin)}
see => {(sam, olive), (cyril, sam), (olive, cyril),(robin,moon1),(yosef,sign1)}
like => {(robin,sam),(olive,sky),(derrick,hotdog),(olive,pickle1),(adam,ball1),(adam,chalk1)}
chase => {(olive,sam),(sam,robin)}
pass => {(derrick,adam),(derrick,project1),(olive,line1)}
leave => {(roberto,dealership1),(roberto,sam)}
read => {(roberto,paper1),(bender,paper1)}

give => {(mia,olive,hotdog1),(cyril,mia,sedan1),(derrick,cyril,iphone1)}

#first buy is for in ex sam bought a sedan in the dealership
buy => {(sam,sedan1,dealership1),(sam,house1),(sam,mia,sedan1),(mia,daniel,fish1),(derrick,mia,computer1)}
drive => {(derrick,car1,corner)}
order => {(mia,robin,sedan1)}
"""

if mode == 1 or mode == 2:
    # Load model valuations
    val = nltk.Valuation.fromstring(v)

    # Initialize assignment g
    g = nltk.Assignment(val.domain)

    # Create model
    m = nltk.Model(val.domain, val)

    # Input sentence
    sent = inputAsString
    
    results = nltk.evaluate_sents([sent], grammar2, m, g)[0]

    for (syntree, semrep, value) in results:
         #print(semrep)
         #print(value)
         if value == True and mode == 1:
            print("I Know.")
            break
         elif value == False and mode == 1:
            print("I Don't think so.")
            break
         elif value == True and mode == 2:
            print("yes.")
            break
         elif value == False and mode == 2:
            print("No.")
            break
elif mode == 3:
    
    parses = [tree.label()['SEM'] for tree in parser.parse(tokens)]    

    formula = parses[0]
    freevar = list(formula.free())[0]

    #print(formula)
    #print(freevar)
    
    # Load model valuations
    val = nltk.Valuation.fromstring(v)

    # Initialize assignment g
    g = nltk.Assignment(val.domain)

    # Create model
    m = nltk.Model(val.domain, val)

    # Find values of the free variable that make the formula true
    answer = list(m.satisfiers(formula, freevar, g))[0]

    # Create inverted valuation dictionary, with just names
    invValNames = {b:a for a,b in val.items() if isinstance(b, str)}
   
    # Find out the name of the entity that is the value for the free variable
    reply = invValNames[answer]

    print(reply)